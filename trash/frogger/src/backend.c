#include "frog_backend.h"
// Загрузка данных текущего уровня из файла и подготовка их для использования в игре
int lvlproc(board_t *map, game_stats_t *stats)
{
    timeout(INITIAL_TIMEOUT - stats->speed * 15); // Время ожидания, в зависимости от текущей скорости игры

    char levelname[LEVELNAME_MAX + 1] = { 0 }; // Массив для хранения имени файла с уровнем

    sprintf(levelname, LEVEL_DIR"%d.txt", stats->level); // переменная для записи, имя файла, уровень игры
    
    FILE *level = fopen(levelname, "r"); // функцией fopen открывается файл с уровнем
    
    int rc = SUCCESS; // флаг для проверки успешности открытия файла

// Цикл обработки каждой строчки файла с уровнем
    if (level) // если НЕ NULL, продолжаем
    {
        for (int i = 0; i < ROWS_MAP && !rc; i++) // цикл по карте игрового поля для каждой строки 
        {
            if (fgets(map->ways[i], COLS_MAP + 2, level) == NULL) // fgets читает строку из файла (файл в переменной level) и передаёт её в массив map->ways[i] из структуры board_t
                rc = ERROR; // если ошибка при чтении строки - ERROR
            else // если всё ок
                map->ways[i][strcspn(map->ways[i], "\n")] = '\0'; // функция strcspn проходит все символы до символа НОВОЙ строки, ВМЕСТО НЕГО ставится НУЛЬ-СИМВОЛ
        }
        fclose(level); // закрывается файл уровня
    }
    else
        rc = ERROR; // если файл уровня НЕ открыт - ERROR

    return rc; // возвращает результат - SUCCESS или ERROR
}
// Обновляет ВИЗУАЛЬНЫЙ прогресс игрока на финишной линии
void add_proggress(board_t *map) // принимает указатель на структуру board_t (текущее состояние игрового поля)
{
    int position = 0; // переменная для отслеживания позиции на финишной линии (символьный массив finish в структуре board_t) 

    for (; map->finish[position] == '0'; position++); // цикл проходит по всем символам массива finish и проверяет, находится ли на позиции ноль (0) - это позволяет найти ПЕРВУЮ не пустую позицию на финишной линии

    for (int progress_cnt = BOARD_M / 5; progress_cnt > 0; progress_cnt--) // Цикл работает, пока инициализированная переменная progress_cnt > 0 (т.е. пока BOARD_M не СТАЛО = 0)
        map->finish[position++] = '0';  // устанавливает символ '0' в текущей позиции на финишной линии.
}
// Что делает эта функция?
bool check_finish_state(player_pos *frog, board_t *map) // принимает указатель на структуру позиции жабы и указатель на структуру игрового поля
{
    bool rc = FALSE; // инициализирует переменную rc на значение FALSE

    if (frog->y == 1) // проверяет строку нахождения жабы в позиции Y = 1
        rc = TRUE; // если жаба на финишной линии, то rc становится TRUE

    return rc;
}
// Проверяет - завершён ЛИ текущий уровень игры
bool check_level_compl(board_t *map) // принимает указатель на структуру board_t (текущее состояние игрового поля)
{
    bool rc = TRUE; // флаг для проверки завершения уровня
    for (int i = 0; i < BOARD_M && rc; i++) // проходит по всем элементам массива finish в структуре map
        if (map->finish[i] != '0') // если элемент массива не равен нулю
            rc = FALSE; // флаг rc сбрасывается на FALSE

    return rc;
}
// Возвращает булево значение (bool), указывающее на наличие  или отсутствие столкновения
bool check_collide(player_pos *frog, board_t *map) // Структура позиции жабы; Игровое поле
{
    bool rc = FALSE; // флаг что нет столкновения

    if (frog->y > MAP_PADDING && frog->y < ROWS_MAP + MAP_PADDING + 1 && // frog->y > MAP_PADDING: проверяет, что вертикальная позиция жабы больше отступа сверху карты 
        map->ways[frog->y - MAP_PADDING - 1][frog->x - 1] == ']') // frog->y < ROWS_MAP + MAP_PADDING + 1: проверяет, что вертикальная позиция жабы меньше общей высоты карты плюс отступы.
        rc = TRUE; // map->ways[frog->y - MAP_PADDING - 1][frog->x - 1] == ']': проверяет, что символ в позиции жабы на карте равен ']'
        // Если все эти условия цикла if истинны
    return rc;
}
// Инициализация НАЧАЛЬНОЙ позиции жабы (x и y)
void frogpos_init(player_pos *frog) // принимает указатель на структуру player_pos, с текущей позицией жабы
{
    frog->x = FROGSTART_X; // константа FROGSTART_X определяет начальную позицию жабы по горизонтали (СЕРЕДИНА КАРТЫ)
    frog->y = FROGSTART_Y; // константа FROGSTART_Y определяет начальную позицию жабы по вертикали (НИЖНЯЯ ГРАНИЦА КАРТЫ)
}
//Инициализация финиша игры (finish_line будет содержать BOARD_M пробелов)
void fill_finish(char *finish_line) // принимает указатель на массив - линию финиша игры (В ТЕТРИСЕ СНИМАЕТСЯ ПРИ НАПОЛНЕНИИ ЛИНИИ)
{
    for (int i = 0; i < BOARD_M; i++) // сравнивает каждый элемент массива с константой BOARD_M и заполняет его пробелом (всего в BOARD_M 30 элементов)
        finish_line[i] = ' ';

    finish_line[BOARD_M] = '\0'; // заполняет последний элемент массива НУЛЬ-СИМВОЛ-ом
}
// Инициализирует структуру значениями
void stats_init(game_stats_t *stats)
{
    stats->level = 1;
    stats->score = 0;
    stats->speed = 1;
    stats->lives = 9;
    stats->won = FALSE; // из ncursers
}
// Сдвигает элементы игрового поля вниз ( Я НЕ ПОНИМАЮ - ПОЧЕМУ ВНИЗ???)
void shift_map(board_t *map) // получает текущее состояние игрового поля
{
    for (int i = 1; i < ROWS_MAP; i += 2) // проходит по строкам (горизонтально) игрового поля со втрой строки, пока i меньше чем ROWS_MAP, обрабатывая ТОЛЬКО чётные строки (i+=2)
    {
        memmove(&map->ways[i][1], &map->ways[i][0], COLS_MAP * sizeof(char)); // копирует все символы из первой половины строки во вторую половину, где COLS_MAP * sizeof(char) - это размер области, которую нужно сдвинуть (скопировать)
        map->ways[i][0] = map->ways[i][COLS_MAP]; // Строка устанавливает первый символ строки в значение последнего символа этой же строки
    }
}//