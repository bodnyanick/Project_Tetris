#include "frogger.h"

int main(void)
{
    WIN_INIT(50); // инициализации окна для работы с бибилиотекой ncurses
    setlocale(LC_ALL, ""); // встроенная функция для установки локали
    print_overlay(); // вывод рамки игрового поля и HUD (статистика)
    game_loop(); // основной цикл игры - логика, управление состоянием, движением игрока и взаимодействиями
    endwin(); // очищает ресурсы библиотеки ncurses перед выходом из программы

    return SUCCESS;
}
// Обрабатывает основной цикл игры.
void game_loop()
{
    board_t map; // инфа по состоянию поля
    game_stats_t stats; // инфа по статистике (счёт, уровень, скорость, жизни)
    player_pos frog; // инфа по позиции жабы

    bool break_flag = TRUE; // флаг для продолжения (TRUE) или остановки (FALSE) игры (значение из библиотеки ncurses)
    int signal = 0; // для хранения последнего действия пользователя и передачи данных в sigact() (обрабатывает действие игрока и обновляет состояние игры)
    frog_state state = START; // Задаёт значение из структуры состояний

    stats_init(&stats); // инициализация статистики игры
// Обеспечивает основную логику игры, обрабатывая пользовательский ввод, изменяя состояние игры и управляя потоком игрового процесса
    while (break_flag) // цикл продолжается, пока break_flag равен TRUE.
    {   
        if (state == GAMEOVER || state == EXIT_STATE || state == FILE_ERROR_STATE) // игра закончилась (GAMEOVER), пользователь хочет выйти (EXIT_STATE) или произошла ошибка с файлом (FILE_ERROR_STATE)
            break_flag = FALSE; // , устанавливается break_flag = FALSE, что приведет к выходу из цикла.

        sigact(get_signal(signal), &state, &stats, &map, &frog); // 1.get_signal(signal) преобразует пользовательский ввод в соответствующий сигнал (например, MOVE_UP, MOVE_DOWN и т.д.); 2.sigact() - это функция, которая обрабатывает этот сигнал в зависимости от текущего состояния игры (state); 3.Функция sigact() принимает указатели на state, stats, map и frog, что позволяет ей изменять эти значения в зависимости от сигнала и текущего состояния игры;

        if (state == MOVING || state == START) // Если текущее состояние игры - MOVING (движение) или START (начало)
            signal = GET_USER_INPUT; // , устанавливается новый сигнал для получения пользовательского ввода.
    }

    if (state == FILE_ERROR_STATE) // Если состояние игры - FILE_ERROR_STATE (ошибка с файлом)
    {
        print_levelerror(); // , выводится сообщение об ошибке
        nodelay(stdscr, FALSE); // , отключается немедленный режим ввода (функция библиотеки ncurcesr)
        getch(); // и ожидается нажатие клавиши.
    }
}